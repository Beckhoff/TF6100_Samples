<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.6">
  <POU Name="UA_MethodCall_DBRecordInsert" Id="{526bd402-143e-4121-abce-e9741065466b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK UA_MethodCall_DBRecordInsert
VAR_INPUT
	bExecute			: BOOL;
	nConnectionHdl		: DWORD;
	nNamespaceIndex		: UINT; 			(* to be retrieved using UA_GetNamespaceIndex *)
	hDBID				: UDINT := 1; 
	pWriteData			: PVOID;
	cbWriteData			: UDINT;			(* Count of bytes to be read*)
	Timeout				: TIME := DEFAULT_ADS_TIMEOUT;
END_VAR
VAR_OUTPUT
	stUASQLState		: ST_UASQLState; 
	cbReadData_R		: UDINT; 
	bDone				: BOOL;
	bBusy				: BOOL;
	bError				: BOOL;
	nErrorID			: DWORD;
END_VAR
VAR
	iRdWrtReqState		: INT;
	RTrig				: R_TRIG;

	fbUA_MethodGetHandle: UA_MethodGetHandle;
	nMethodHdl			: DWORD;
	ObjectNodeID		: ST_UANodeID;
	MethodNodeID		: ST_UANodeID;

	fbUA_MethodCall		: UA_MethodCall;
	InputArguments		: ARRAY [1..nNumberOfInputArguments] OF ST_UAMethodArgInfo; (*ReadWriteReq has 6 input parameters *)
	nArg				: INT;
	nInputData			: ARRAY [1..nInputArgSize] OF BYTE; (* NetId(24) + Port(2)+ IG(4)+ IO(4) *)
	nOffset				: UDINT;
	stOutputArgInfo		: ARRAY [1..nNumberOfOutputArguments] OF ST_UAMethodArgInfo;
	{attribute 'hide'}
	nIndexOffset		: DINT := 16#1; 		(* IndexOffset*)
	
	fbUA_MethodReleaseHandle	: UA_MethodReleaseHandle;

	stDBRecordInsertRes	: ST_UAMethodCall_DBRecordInsertRes; 
	bInputDataError 	: BOOL;
END_VAR
VAR CONSTANT
	nInputArgSize			: UDINT := 34; (* NetId(24) + Port(2)+ IG(4)+ IO(4) *)
	nNumberOfInputArguments : UDINT := 6;
	nNumberOfOutputArguments : UDINT := 2;
	
	sNetID				: T_AmsNetId:='127.0.0.1.1.1'; 		(* AmsNetId OF the Target *)
	nPort				: INT := 21372;			(* Port number	*)	(* AMSPORT_DATABASESRV := 21372 = 16#537C*)
	nIndexGroup			: DINT := 16#80002;		(* IndexGroup*)		(* DBADS_IGR_DBRECORDINSERT *)
	cbReadData			: UDINT := SIZEOF(ST_UASQLState);			(* Count of bytes to be read*)
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
ADSReadWriteReq(
******** Input Arguments ********
	string sNetID, 		: AmsNetId of the Target
	int16 Port,			: Port number	
	int32 IndexGroup,		: IndexGroup
	int32 IndexOffset,		: IndexOffset
	ByteString WriteData	: Data to be written to the device
	uint32 cbReadData		: Count of bytes to be read
******** Output Arguments ********
	bytestring Data		: count of bytes actually read
);
*)

RTrig(CLK:= bExecute);

CASE iRdWrtReqState OF

0:	(* Get Method Handle *)
	IF RTrig.Q THEN
		bBusy		:= TRUE;
		bDone 		:= FALSE;
		bError		:= FALSE;
		nErrorID	:= 0;
		ObjectNodeID.eIdentifierType := eUAIdentifierType_String;
		ObjectNodeID.nNamespaceIndex := nNamespaceIndex;
		ObjectNodeID.sIdentifier	 := 'ADSAMS';
	
		MethodNodeID.eIdentifierType := eUAIdentifierType_String;
		MethodNodeID.nNamespaceIndex := nNamespaceIndex;
		MethodNodeID.sIdentifier	 := 'ADSAMS.AdsReadWriteReq';

		M_Init();
		IF bInputDataError = FALSE THEN
			iRdWrtReqState 	:= iRdWrtReqState + 1;
		ELSE
			bBusy 		:= FALSE;
			bError 		:= TRUE;
			nErrorID 	:= DEVICE_INVALIDSIZE; //16#705 parameter size not correct
		END_IF
		MEMSET(ADR(stDBRecordInsertRes),0,SIZEOF(stDBRecordInsertRes));
		MEMSET(ADR(stUASQLState),0,SIZEOF(stUASQLState));
	END_IF


1:	(* Method Get Handle *)
	fbUA_MethodGetHandle(
			Execute			:= TRUE,
			ConnectionHdl	:= nConnectionHdl,
			ObjectNodeID	:= ObjectNodeID,
			MethodNodeID 	:= MethodNodeID,
			Timeout			:= Timeout,
			MethodHdl		=> nMethodHdl
		);
	IF NOT fbUA_MethodGetHandle.Busy THEN
		fbUA_MethodGetHandle(Execute := FALSE);

		IF NOT fbUA_MethodGetHandle.Error THEN
			(*  *)
			iRdWrtReqState := iRdWrtReqState + 1; (* Call Method *)
		ELSE
			bError			:= TRUE;
			nErrorID		:= fbUA_MethodGetHandle.ErrorID;
			iRdWrtReqState 	:= 3; (* Release Handle *)
		END_IF
	END_IF


2:	(* Method Call *)
	fbUA_MethodCall(
		Execute					:= TRUE,
		ConnectionHdl			:= nConnectionHdl,
		MethodHdl				:= nMethodHdl,
		nNumberOfInputArguments := nNumberOfInputArguments,		(* 6 *)
		pInputArgInfo			:= ADR(InputArguments),
		cbInputArgInfo			:= SIZEOF(InputArguments),
		pInputArgData			:= ADR(nInputData),
		cbInputArgData			:= nOffset,
		pInputWriteData			:= pWriteData,
		cbInputWriteData		:= cbWriteData,
		nNumberOfOutputArguments:= nNumberOfOutputArguments,		(* 2 *)
		pOutputArgInfo			:= ADR(stOutputArgInfo),
		cbOutputArgInfo			:= SIZEOF(stOutputArgInfo),
		pOutputArgInfoAndData	:= ADR(stDBRecordInsertRes),
		cbOutputArgInfoAndData	:= SIZEOF(stDBRecordInsertRes),
		Timeout					:= Timeout
	);
	IF NOT fbUA_MethodCall.Busy THEN
		fbUA_MethodCall(Execute := FALSE, cbRead_R => cbReadData_R);
		IF NOT fbUA_MethodCall.Error THEN
			(*  *)
			iRdWrtReqState 	:= iRdWrtReqState + 1; (* Release handle *)
			stUASQLState.nReturnCode := stDBRecordInsertRes.stSQLStateInternal.nReturnCode;
			(* ------------ copied from TcDatabase.lib *)
			IF stUASQLState.nReturnCode <> 0 THEN 
				bError := TRUE;
				nErrorID := stUASQLState.nReturnCode;
				stUASQLState.sSQLState		:= stDBRecordInsertRes.stSQLStateInternal.sSQLState;
				stUASQLState.nSQLErrorCode 	:= stDBRecordInsertRes.stSQLStateInternal.nSQLErrorCode;
			ELSE
				stUASQLState.sSQLState		:= '00000';	
				stUASQLState.nSQLErrorCode 	:= 0;		
			END_IF		
			(* ------------- copied from TcDatabase.lib *)
		ELSE
			bError			:= TRUE;
			nErrorID		:= fbUA_MethodCall.ErrorID;
			iRdWrtReqState	:= 3; (* Release handle *)
		END_IF
	END_IF


3:	(* Release Method Handle *)
	fbUA_MethodReleaseHandle(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl,
		MethodHdl		:= nMethodHdl,
		Timeout			:= Timeout
	);

	IF NOT fbUA_MethodReleaseHandle.Busy THEN
		fbUA_MethodReleaseHandle(Execute := FALSE);
		bBusy := FALSE;
		IF NOT fbUA_MethodReleaseHandle.Error THEN
			(* session closed *)
			bDone := TRUE;
			iRdWrtReqState 	:= 0; (* idle *)
		ELSE
			bError			:= TRUE;
			nErrorID		:= fbUA_MethodReleaseHandle.ErrorID;
			iRdWrtReqState 	:= 0; (* idle *)
		END_IF
	END_IF
END_CASE
]]></ST>
    </Implementation>
    <Action Name="M_Init" Id="{3c9b8b43-c9ab-411f-a31e-9811f0a572e2}">
      <Implementation>
        <ST><![CDATA[
//sNetID				:='127.0.0.1.1.1'; 		(* AmsNetId OF the Target *)
//nPort				:= 21372;					(* Port number	*)	(* AMSPORT_DATABASESRV := 21372 = 16#537C*)
//nIndexGroup			:= 16#80002;			(* IndexGroup*)		(* DBADS_IGR_DBRECORDINSERT *)
nIndexOffset		:= UDINT_TO_DINT(hDBID); 	(* IndexOffset*)
//cbReadData			:= SIZEOF(ST_UASQLState);	(* Count of bytes to be read*)

	
bInputDataError := FALSE; 
nOffset := 0;
MEMSET(ADR(InputArguments),0,SIZEOF(InputArguments));
MEMSET(ADR(nInputData),0,SIZEOF(nInputData));

nArg := 1;
(*sNetID := sAmsNetID;*)	(********** NET ID **********)
InputArguments[nArg].DataType			:= eUAType_String;
InputArguments[nArg].ValueRank			:= -1; 						(* Scalar = -1 or Array *)
InputArguments[nArg].ArrayDimensions[1]	:= 0; 						(* Number of Dimension in case its an array *)
InputArguments[nArg].nLenData			:= INT_TO_UDINT(LEN(sNetId)) + 1;	
IF nOffset + INT_TO_UDINT(LEN(sNetId))+1 > nInputArgSize THEN 
	bInputDataError := TRUE;
	RETURN;
ELSE
	MEMCPY(ADR(nInputData)+nOffset,ADR(sNetId),INT_TO_UDINT(LEN(sNetId))+1);			(* VALUE in BYTES FORM *)
	nOffset := nOffset + INT_TO_UDINT(LEN(sNetId))+1;
END_IF

nArg := nArg + 1;
(* nPort := 851;*)			(********** PORT **********)
InputArguments[nArg].DataType			:= eUAType_Int16;
InputArguments[nArg].ValueRank			:= -1; 						(* Scalar = -1 or Array *)
InputArguments[nArg].ArrayDimensions[1]	:= 0; 						(* Number of Dimension in case its an array *)
InputArguments[nArg].nLenData			:= SIZEOF(nPort);			(* Length if its a STRING *)
IF nOffset + SIZEOF(nPort) > nInputArgSize THEN 
	bInputDataError := TRUE;
	RETURN;
ELSE
	MEMCPY(ADR(nInputData)+nOffset,ADR(nPort),SIZEOF(nPort));			(* VALUE in BYTES FORM *)
	nOffset := nOffset + SIZEOF(nPort);
END_IF

nArg := nArg + 1;
(*nIndexGroup := 16#4020;*)	(********** INDEX GROUP **********)
InputArguments[nArg].DataType			:= eUAType_Int32;
InputArguments[nArg].ValueRank			:= -1; 							(* Scalar = -1 or Array *)
InputArguments[nArg].ArrayDimensions[1]	:= 0; 							(* Number of Dimension in case its an array *)
InputArguments[nArg].nLenData			:= SIZEOF(nIndexGroup);			(* Length if its a STRING *)
IF nOffset + SIZEOF(nIndexGroup) > nInputArgSize THEN 
	bInputDataError := TRUE;
	RETURN;
ELSE
	MEMCPY(ADR(nInputData)+nOffset,ADR(nIndexGroup),SIZEOF(nIndexGroup));		(* VALUE in BYTES FORM *)
	nOffset := nOffset + SIZEOF(nIndexGroup);
END_IF

nArg := nArg + 1;
(*nIndexOffset := 0; *)		(********** INDEX OFFSET **********)
InputArguments[nArg].DataType			:= eUAType_Int32;
InputArguments[nArg].ValueRank			:= -1; 							(* Scalar = -1 or Array *)
InputArguments[nArg].ArrayDimensions[1]	:= 0; 							(* Number of Dimension in case its an array *)
InputArguments[nArg].nLenData			:= SIZEOF(nIndexOffset);		(* Length if its a STRING *)
IF nOffset + SIZEOF(nIndexOffset) > nInputArgSize THEN 
	bInputDataError := TRUE;
	RETURN;
ELSE
	MEMCPY(ADR(nInputData)+nOffset,ADR(nIndexOffset),SIZEOF(nIndexOffset));	(* VALUE in BYTES FORM *)
	nOffset := nOffset + SIZEOF(nIndexOffset);
END_IF

nArg := nArg + 1;
(*Data := 2; *)		(*********** WriteData ***********)
InputArguments[nArg].DataType			:= eUAType_ByteString;
InputArguments[nArg].ValueRank			:= -1; 						(* Scalar = -1 or Array *)
InputArguments[nArg].ArrayDimensions[1]	:= 0; 						(* Number of Dimension in case its an array *)
InputArguments[nArg].nLenData			:= cbWriteData;				(* Length if its a STRING *)


nArg := nArg + 1;
(*Data := 2; *)		(*********** ReadData size ***********)
InputArguments[nArg].DataType			:= eUAType_UInt32;
InputArguments[nArg].ValueRank			:= -1; 						(* Scalar = -1 or Array *)
InputArguments[nArg].ArrayDimensions[1]	:= 0; 						(* Number of Dimension in case its an array *)
InputArguments[nArg].nLenData			:= SIZEOF(cbReadData);		(* Length if its a STRING *)


//************** Prepare Output Argument information ***********
stOutputArgInfo[1].nLenData := SIZEOF(stDBRecordInsertRes.stSQLStateInternal.nReturnCode);
stOutputArgInfo[2].nLenData := SIZEOF(stDBRecordInsertRes.stSQLStateInternal)- stOutputArgInfo[1].nLenData ; 

]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="UA_MethodCall_DBRecordInsert">
      <LineId Id="3" Count="133" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="UA_MethodCall_DBRecordInsert.M_Init">
      <LineId Id="2" Count="88" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>