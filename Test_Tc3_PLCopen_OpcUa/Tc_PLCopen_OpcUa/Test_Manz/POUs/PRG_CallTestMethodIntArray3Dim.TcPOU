<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.6">
  <POU Name="PRG_CallTestMethodIntArray3Dim" Id="{41a6d0e6-fd6a-4720-9c89-727eca245c2f}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM PRG_CallTestMethodIntArray3Dim
VAR
	fbUA_Connect			: UA_Connect;
	SessionConnectInfo		: ST_UASessionConnectInfo;
	sOpcUA_URL				: STRING(MAX_STRING_LENGTH);
	nConnectionHdl			: DWORD;
	fbUA_GetNamespaceIndex	: UA_GetNamespaceIndex;
	nNamespaceIndex			: UINT;
	
	fbUA_MethodGetHandle	: UA_MethodGetHandle;
	nMethodHdl				: DWORD;
	ObjectNodeID			: ST_UANodeID;
	MethodNodeID			: ST_UANodeID;
	fbUA_MethodCall			: UA_MethodCall;
	InputArguments			: ARRAY[1..nNumberOfInputArguments] OF ST_UAMethodArgInfo;
	stOutputArgInfo			: ARRAY [1..nNumberOfOutputArguments] OF ST_UAMethodArgInfo;
	/// Bytes to be read 
	nInputData				: ARRAY[1..nInputArgSize] OF BYTE;
	/// Count of bytes to be written 
	cbWriteData: UDINT;
	///CallInOutMultiParams(numberIn1(uInt32),numberIn2(UInt32),numberOut1(UInt32),numberOut2(UINT32));
	//numberIn3Dim: ARRAY[1..3,1..3,1..3] OF UDINT := [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27];
	numberIn3Dim			: ARRAY[1..2,1..2,1..2] OF DINT := [1,2,3,4,5,6,7,8];
	OutputArgAndData		: ST_UAMethodCall_CallTestMethodIntArray3Dim;
	
	fbUA_MethodReleaseHandle	: UA_MethodReleaseHandle;
	
	fbUA_Disconnect	: UA_Disconnect;
	
	bTest			: BOOL := TRUE;
	bDone			: BOOL;
	bBusy			: BOOL;
	bError			: BOOL;
	nErrorID		: DWORD;
	iState			: INT;
	nOffset			: UDINT;
	nArg			: INT;
	bInputDataError	: BOOL;
END_VAR
VAR CONSTANT
	nNumberOfInputArguments : UDINT := 1;
	nNumberOfOutputArguments: UDINT := 1; 
	nInputArgSize 			: UDINT := 32;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
CallInOut1DimParams(	[numberIn1(uInt32),	numberIn2(UInt32)]
						[numberOut1(UInt32),numberOut2(UINT32),	numberOut3(UINT32)]
);
*)

CASE iState OF

0:	(* idle *)
	IF bTest THEN
		bTest		:= FALSE;
		bError		:= FALSE;
		nErrorID	:= 0;
		(* Parameterize *)
		//sOpcUA_URL		:= 'opc.tcp://localhost:48032';	(* OpcUA Url of the device with ip address *)
		sOpcUA_URL		:= 'opc.tcp://localhost-nb:4842';	(* OpcUA Url of the device with ip address *)

		SessionConnectInfo.tConnectTimeout 		:= T#9M;
		SessionConnectInfo.tSessionTimeout 		:= T#9M;
		SessionConnectInfo.sApplicationName		:= '';
//		SessionConnectInfo.sApplicationUri 		:= '';
		SessionConnectInfo.eSecurityMode 		:= eUASecurityMsgMode_None;
		SessionConnectInfo.eSecurityPolicyUri 	:= eUASecurityPolicy_None;
		SessionConnectInfo.eTransportProfileUri := eUATransportProfileUri_UATcp;

		iState	:= iState + 1;
	END_IF


1:	(* open UA session *)
	fbUA_Connect(
		Execute				:= TRUE,
		ServerURL			:= sOpcUA_URL,
		SessionConnectInfo	:= SessionConnectInfo,
		Timeout				:= T#10S,
		ConnectionHdl		=> nConnectionHdl
	);

	IF NOT fbUA_Connect.Busy THEN
		fbUA_Connect(Execute := FALSE);

		IF NOT fbUA_Connect.Error THEN
			(* connected *)
			iState := iState + 1;
		ELSE
			bError			:= TRUE;
			nErrorID		:= fbUA_Connect.ErrorID;
			nConnectionHdl	:= 0;
			iState 			:= 0; (* idle *)
		END_IF
	END_IF


2:	(* GetNS Index *)
	fbUA_GetNamespaceIndex(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl,
		NamespaceUri	:= 'http://manz.com/ManzAddonTestForControl/',
		NamespaceIndex	=> nNamespaceIndex
	);

	IF NOT fbUA_GetNamespaceIndex.Busy THEN
		fbUA_GetNamespaceIndex(Execute := FALSE);

		IF NOT fbUA_GetNamespaceIndex.Error THEN
			(* namespace index read successfully *)
			iState 		:= iState + 1; (* get node handle *)
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_GetNamespaceIndex.ErrorID;
			iState 		:= 7; (* disconnect *)
		END_IF
	END_IF

3:	(* Get Method Handle *)
		ObjectNodeID.eIdentifierType := eUAIdentifierType_String;
		ObjectNodeID.nNamespaceIndex := nNamespaceIndex;
		ObjectNodeID.sIdentifier	:= 'ControlTest';
	
		MethodNodeID.eIdentifierType := eUAIdentifierType_String;
		MethodNodeID.nNamespaceIndex := nNamespaceIndex;
		MethodNodeID.sIdentifier	:= 'ControlTest.TestMethodIntArray3Dim';

		M_Init();
		IF bInputDataError = FALSE THEN
			iState 	:= iState + 1;
		ELSE
			bBusy		:= FALSE; 
			bError 		:= TRUE;
			nErrorID 	:= 16#70A; //out of memory
		END_IF


4:	(* Method Get Handle *)
	fbUA_MethodGetHandle(
			Execute			:= TRUE,
			ConnectionHdl	:= nConnectionHdl,
			ObjectNodeID	:= ObjectNodeID,
			MethodNodeID 	:= MethodNodeID,
			MethodHdl		=> nMethodHdl
		);
	IF NOT fbUA_MethodGetHandle.Busy THEN
		fbUA_MethodGetHandle(Execute := FALSE);

		IF NOT fbUA_MethodGetHandle.Error THEN
			(*  *)
			iState := iState + 1; (* Call Method *)
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_MethodGetHandle.ErrorID;
			iState	 	:= 6; (* Release method Handle *)
		END_IF
	END_IF


5:	(* Method Call *)
	fbUA_MethodCall(
		Execute					:= TRUE,
		Timeout					:= T#20S,
		ConnectionHdl			:= nConnectionHdl,
		MethodHdl				:= nMethodHdl,
		nNumberOfInputArguments := nNumberOfInputArguments,		(* 1 *)
		pInputArgData			:= ADR(nInputData),
		cbInputArgData			:= cbWriteData,
		pInputArgInfo			:= ADR(InputArguments),
		cbInputArgInfo			:= SIZEOF(InputArguments),
		nNumberOfOutputArguments:= nNumberOfOutputArguments,
		pOutputArgInfo			:= ADR(stOutputArgInfo),
		cbOutputArgInfo			:= SIZEOF(stOutputArgInfo),
		pOutputArgInfoAndData	:= ADR(OutputArgAndData),
		cbOutputArgInfoAndData	:= SIZEOF(OutputArgAndData),
			
	);
	IF NOT fbUA_MethodCall.Busy THEN
		fbUA_MethodCall(Execute := FALSE);

		IF NOT fbUA_MethodCall.Error THEN
			(*  *)
			iState 	:= iState + 1; (* Release handle *)
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_MethodCall.ErrorID;
			iState		:= 6; (* Release method handle *)
		END_IF
	END_IF


6:	(* Release Method Handle *)
	fbUA_MethodReleaseHandle(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl,
		MethodHdl		:= nMethodHdl
	);

	IF NOT fbUA_MethodReleaseHandle.Busy THEN
		fbUA_MethodReleaseHandle(Execute := FALSE);
		bBusy := FALSE;
		IF NOT fbUA_MethodReleaseHandle.Error THEN
			(* session closed *)
			iState 	:= 7; (* Disconnect *)
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_MethodReleaseHandle.ErrorID;
			iState 		:= 7; (* Disconnect *)
		END_IF
	END_IF
	
7:	(* Disconnect *) 
	fbUA_Disconnect(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl
	);

	IF NOT fbUA_Disconnect.Busy THEN
		fbUA_Disconnect(Execute := FALSE);

		IF NOT fbUA_Disconnect.Error THEN
			(* disconnected *)
			iState 			:= 0; (* idle *)
			bDone 	:= TRUE;
			bBusy 	:= FALSE;
		ELSE
			bBusy 	:= FALSE;
			bError			:= TRUE;
			nErrorID		:= fbUA_Disconnect.ErrorID;
			iState 			:= 0; (* idle *)
			nConnectionHdl	:= 0;
		END_IF
	END_IF
END_CASE
]]></ST>
    </Implementation>
    <Action Name="M_Init" Id="{5ba019a6-12db-47a8-ac94-8e40fa9be864}">
      <Implementation>
        <ST><![CDATA[bInputDataError := FALSE; 
nOffset := 0;
MEMSET(ADR(InputArguments),0,SIZEOF(InputArguments));
MEMSET(ADR(nInputData),0,SIZEOF(nInputData));

nArg := 1;
(*numberIn1*)			(********** Input parameter 1 **********)
InputArguments[nArg].DataType			:= eUAType_Int32;
InputArguments[nArg].ValueRank			:= 3; 							(* Scalar = -1 or 1Dim-Array =1*)
InputArguments[nArg].ArrayDimensions[1]	:= 2; 							(* Number of Dimension in case its an array *)
InputArguments[nArg].ArrayDimensions[2]	:= 2; 
InputArguments[nArg].ArrayDimensions[3]	:= 2; 		
InputArguments[nArg].nLenData			:= SIZEOF(numberIn3Dim);			(* Length if its a STRING *)

IF nOffset + SIZEOF(numberIn3Dim) > nInputArgSize THEN 
	bInputDataError := TRUE;
	RETURN;
ELSE
	MEMCPY(ADR(nInputData)+nOffset,ADR(numberIn3Dim),SIZEOF(numberIn3Dim));				(* VALUE in BYTES FORM *)
	nOffset := nOffset + SIZEOF(numberIn3Dim);
END_IF

cbWriteData := nOffset;

//************** Prepare Output Argument information ***********
stOutputArgInfo[1].nLenData := SIZEOF(OutputArgAndData.output1);
	]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="PRG_CallTestMethodIntArray3Dim">
      <LineId Id="3" Count="189" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="PRG_CallTestMethodIntArray3Dim.M_Init">
      <LineId Id="2" Count="25" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>