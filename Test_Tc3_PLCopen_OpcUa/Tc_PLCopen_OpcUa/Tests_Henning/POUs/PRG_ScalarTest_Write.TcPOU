<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.24">
  <POU Name="PRG_ScalarTest_Write" Id="{3301304e-1ea3-4583-b8b5-36383fec72da}">
    <Declaration><![CDATA[PROGRAM PRG_ScalarTest_Write
VAR
	fbUA_Connect: UA_Connect;
	SessionConnectInfo: ST_UASessionConnectInfo;
	sOpcUA_URL: STRING(MAX_STRING_LENGTH);
	nConnectionHdl: DWORD;
	fbUA_GetNamespaceIndex: UA_GetNamespaceIndex;
	sNamespaceUri: STRING(MAX_STRING_LENGTH);
	nNamespaceIndex: UINT;
	fbUA_NodeGetHandle: UA_NodeGetHandle;
	NodeID: ST_UANodeID;
	nNodeHdl: DWORD;
	fbUA_Write: UA_Write;
	stIndexRange: ARRAY[1..nMaxIndexRange] OF ST_UAIndexRange;
	nIndexRangeCount: UINT;
	stNodeAddInfo: ST_UANodeAdditionalInfo;
	/// UDINT := 12312345;		// change according to the type of variable
	nWriteData: STRING := 'Hallo';
	Variable: ARRAY[1..nMaxReadData] OF BYTE;
	cbData: UDINT;
	fbUA_NodeReleaseHandle: UA_NodeReleaseHandle;
	fbUA_Disconnect: UA_Disconnect;
	iState: INT;
	bTest: BOOL := TRUE;
	bDone: BOOL;
	bBusy: BOOL;
	bError: BOOL;
	nErrorID: DWORD;
	nLoopVars: UINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE iState OF
0:	(* idle *)
	IF bTest THEN
		bTest	:= FALSE;
		bError	:= FALSE;
		nErrorID	:= 0;
		bBusy := TRUE; 

		(* Parameterize 
		GVL_ScalarTests.NodeID_WriteCommands[0].bBool := TRUE; 
		GVL_ScalarTests.NodeID_WriteCommands[1].sString := 'WriteTest'; 
		GVL_ScalarTests.NodeID_WriteCommands[2].bByte := 123; 
		GVL_ScalarTests.NodeID_WriteCommands[3].nInt := 124; 
		GVL_ScalarTests.NodeID_WriteCommands[4].nUdint := 125; 
		GVL_ScalarTests.NodeID_WriteCommands[5].nLReal := 1.23456; //R8x 
		GVL_ScalarTests.NodeID_WriteCommands[6].bByte := 111; 
		GVL_ScalarTests.NodeID_WriteCommands[7].nInt := 112; 
		GVL_ScalarTests.NodeID_WriteCommands[8].nUdint := 113; 
		*)
		
		
		
		SessionConnectInfo.tConnectTimeout 		:= T#9S;
		SessionConnectInfo.tSessionTimeout 		:= T#9S;
		SessionConnectInfo.sApplicationName		:= '';
		SessionConnectInfo.sApplicationUri 		:= '';
		SessionConnectInfo.eSecurityMode 		:= eUASecurityMsgMode_None;
		SessionConnectInfo.eSecurityPolicyUri 	:= eUASecurityPolicy_None;
		SessionConnectInfo.eTransportProfileUri := eUATransportProfileUri_UATcp;
		
		stNodeAddInfo.nIndexRangeCount := nIndexRangeCount;
		stNodeAddInfo.stIndexRange := stIndexRange;
		iState	:= iState + 1;
	END_IF

1:	(* open UA session *)
	fbUA_Connect(
		Execute				:= TRUE,
		ServerURL			:= GVL_ScalarTests.sOpcUA_URL,
		SessionConnectInfo	:= SessionConnectInfo,
		Timeout				:= T#10S,
		ConnectionHdl		=> nConnectionHdl
	);

	IF NOT fbUA_Connect.Busy THEN
		fbUA_Connect(Execute := FALSE);

		IF NOT fbUA_Connect.Error THEN
			(* session open *)
			iState := iState + 1;
		ELSE
			bError			:= TRUE;
			nErrorID		:= fbUA_Connect.ErrorID;
			nConnectionHdl	:= 0;
			iState 			:= 0; (* idle *)
		END_IF
	END_IF


2:	(* GetNS Index *)
	fbUA_GetNamespaceIndex(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl,
		NamespaceUri	:= GVL_ScalarTests.sNodeIDNamespace,
		NamespaceIndex	=> nNamespaceIndex
	);

	IF NOT fbUA_GetNamespaceIndex.Busy THEN
		fbUA_GetNamespaceIndex(Execute := FALSE);

		IF NOT fbUA_GetNamespaceIndex.Error THEN
			(* session closed *)
			iState 		:= iState + 1; (* idle *)
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_GetNamespaceIndex.ErrorID;
			iState 		:= 6; (* idle *)
		END_IF
	END_IF


3:	(* Get Node Handle *)
	NodeID.eIdentifierType := eUAIdentifierType_String;
	NodeID.nNamespaceIndex := nNamespaceIndex;
	NodeID.sIdentifier	:= GVL_ScalarTests.NodeID_Identifiers[nLoopVars]; // 'GVL_static.stat_BSTR_0';
	fbUA_NodeGetHandle(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl,
		NodeID			:= NodeID,
		NodeHdl			=> nNodeHdl
	);

	IF NOT fbUA_NodeGetHandle.Busy THEN
		fbUA_NodeGetHandle(Execute := FALSE);

		IF NOT fbUA_NodeGetHandle.Error THEN
			(* session closed *)
			IF SIZEOF(nWriteData) <= nMaxReadData THEN 
				iState 		:= iState + 1; (* idle *)
				MEMSET(ADR(Variable),0,SIZEOF(Variable));
				MEMCPY(ADR(Variable),ADR(nWriteData),SIZEOF(nWriteData));
			ELSE
				//cannot write buffer too small -> increase the value of nMaxData in GVL
				bError		:= TRUE;
				iState 		:= 6; (* idle *)
			END_IF
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_NodeGetHandle.ErrorID;
			iState 		:= 6; (* idle *)
		END_IF
	END_IF


4: 	(* UA_Write *)
	fbUA_Write(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl,
		NodeHdl			:= nNodeHdl,
		stNodeAddInfo	:= stNodeAddInfo,
		cbData			:= GVL_ScalarTests.NodeID_Sizes[nLoopVars], //SIZEOF(nWriteData),
		pVariable		:= ADR(GVL_ScalarTests.NodeID_WriteCommands[nLoopVars].nData) // Variable		:= Variable
		);

	IF NOT fbUA_Write.Busy THEN
		fbUA_Write(
			Execute 		:= FALSE);

		IF NOT fbUA_Write.Error THEN
			(* session closed *)
			iState 		:= iState + 1; (* idle *)
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_Write.ErrorID;
			iState 		:= 6; (* idle *)
		END_IF
	END_IF


5:	(* Release Node Handle *)
	fbUA_NodeReleaseHandle(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl,
		NodeHdl			:= nNodeHdl
	);

	IF NOT fbUA_NodeReleaseHandle.Busy THEN
		fbUA_NodeReleaseHandle(Execute := FALSE);

		IF NOT fbUA_NodeReleaseHandle.Error THEN
			(* session closed *)
			iState 		:= iState + 1; (* idle *)
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_NodeReleaseHandle.ErrorID;
			iState 		:= 6; (* idle *)
		END_IF
	END_IF


6:	(* close session *)
	fbUA_Disconnect(
		Execute			:= TRUE,
		ConnectionHdl	:= nConnectionHdl
	);

	IF NOT fbUA_Disconnect.Busy THEN
		fbUA_Disconnect(Execute := FALSE);

		IF NOT fbUA_Disconnect.Error THEN
			(* session closed *)
			iState 		:= 0; (* idle *)			//restart with next var, if existing in array
			IF(nLoopVars < nEndOfNodeIDVars) THEN
				nLoopVars := nLoopVars+1;
				bTest := TRUE;
			ELSE 
				bBusy 		:= FALSE;
				//prepare for next call 
				nLoopVars := 0;
			END_IF
		ELSE
			bError		:= TRUE;
			nErrorID	:= fbUA_Disconnect.ErrorID;
			iState 		:= 0; (* idle *)
			nConnectionHdl	:= 0;
		END_IF
	END_IF
END_CASE
]]></ST>
    </Implementation>
    <ObjectProperties />
  </POU>
</TcPlcObject>